% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sus_socio_add_census.R
\name{sus_socio_add_census}
\alias{sus_socio_add_census}
\title{Add Census Socioeconomic variables to Health Data}
\usage{
sus_socio_add_census(
  df,
  dataset = "population",
  year = 2010,
  vars = NULL,
  aggregation_fun = "sum",
  join_muni_col = NULL,
  use_cache = TRUE,
  cache_dir = "~/.climasus4r_cache/census",
  lang = "pt",
  translate_columns = TRUE,
  standardize_values = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{df}{A \code{data.frame} or \code{sf} object containing health data. Typically the output from \code{sus_join_spatial()} function.}

\item{dataset}{Character string specifying the census dataset to use. Options:
\itemize{
\item \code{"population"} - Population microdata (default)
\item \code{"households"} - Household microdata
\item \code{"families"} - Family microdata
\item \code{"mortality"} - Mortality microdata
\item \code{"emigration"} - Emigration microdata
\item \code{"tracts"} - Census tract aggregate data (coming soon...)
}}

\item{year}{Integer specifying census year. Options: \code{2010} (default) or \code{2000}.
Note: Dataset availability varies by year.}

\item{vars}{Character vector specifying census variables to add. Use \code{sus_census_explore()} to select available variables.
If \code{NULL}, returns all available variables (not recommended for large datasets).}

\item{aggregation_fun}{Character. Method to aggregate microdata to municipality level:
\itemize{
\item \code{"sum"} - Sums the selected variables by municipality (e.g., for total population).
\item \code{"mean"} - Averages the selected variables (e.g., for income).
\item \code{"median"}, \code{"min"}, \code{"max"}, \code{"sd"}, \code{"q25"}, \code{"q75"}, \code{"q95"}, and \code{"q99"}.
}}

\item{join_muni_col}{Character string specifying the column in df containing the \strong{6 or 7-digit IBGE municipality code}. If \code{NULL}, detects common SUS patterns (e.g., \code{code_muni}).}

\item{use_cache}{Logical. If \code{TRUE} (default), uses censobr's caching system to store
downloaded data locally for faster subsequent access.}

\item{cache_dir}{Character string specifying cache directory path. Defaults to
\code{"~/.climasus4r_cache/census"}.The function automatically calls \code{censobr::set_censobr_cache_dir(cache_dir)} to ensure consistency across the ecosystem.}

\item{lang}{Character string specifying language for messages. Options: \code{"pt"} (Portuguese, default), \code{"en"} (English), \code{"es"} (Spanish).}

\item{translate_columns}{Logical. If TRUE, translates column names. Default is TRUE.}

\item{standardize_values}{Logical. If TRUE, standardizes categorical values. Default is TRUE.}

\item{verbose}{Logical. If \code{TRUE} (default), prints progress messages and download progress bar.}
}
\value{
Returns the input \code{data.frame} or \code{sf} object with additional columns. If the input is an sf object, the spatial geometry and CRS are strictly preserved through a join.
}
\description{
Enriches health data with socioeconomic indicators from Brazilian Census using
the \code{censobr} package. Provides aggregation of microdata to municipality level. Supports multiple census datasets (population, households,
families, mortality, emigration) with intelligent caching and optimized performance for large datasets using Arrow/Parquet format.
}
\details{
\strong{Integration with censobr package}:
This function is a wrapper around censobr's dataset-specific functions
(\code{read_population()}, \code{read_households()}, etc.), providing seamless integration
with the climasus4r ecosystem.

\strong{Geographic Columns}:
The function automatically inherits and matches geographic columns following
the geobr/censobr standard:
\itemize{
\item \code{code_muni} - 7-digit municipality code
\item \code{code_state} - 2-digit state code
\item \code{abbrev_state} - State abbreviation (e.g., "AM")
\item \code{name_state} - State name
\item \code{code_region} - Region code
\item \code{name_region} - Region name
\item \code{code_weighting} - Weighting area code
}

\strong{Automatic Column Detection}:
If \code{join_muni_col = NULL}, the function automatically detects the appropriate code municipality
column based on common SUS patterns:
\itemize{
\item \strong{Municipality}: \code{residence_municipality_code}, \code{municipality_code},
\code{codigo_municipio}, \code{CODMUNRES}, etc.
}
\strong{Performance Optimization}:
The function uses Arrow/Parquet format for efficient larger-than-memory dataset handling:
\itemize{
\item Downloads data only once (cached locally)
\item Filters municipalities BEFORE loading to RAM
\item Uses \code{dplyr::collect()} only after filtering
\item Uses \code{sfarrow} pak for spatial filtering
}
\strong{Spatial Data Support}:
If \code{df} is an \code{sf} object from \code{sus_join_spatial()}, geometries are preserved in the output.
}
\examples{
\dontrun{
library(climasus4r)

# Prepare spatial health data
sf_sim <- sus_data_import(uf = "SP", year = 2023, system = "SIM-DO") \%>\%
  sus_data_standardize(lang = "pt") \%>\%
  sus_join_spatial(level = "munic", lang = "pt")

# Add census population data
sf_enriched <- sus_socio_add_census(
  df = sf_sim,
  dataset = "population",
  vars = c("V0001", "V0002"),
  year = 2010,
  lang = "pt"
)
}
}
\references{
Pereira, Rafael H. M.; Barbosa, Rogerio J. (2023) censobr: Download Data from Brazilâ€™s Population Census. R package version v0.4.0, https://CRAN.R-project.org/package=censobr. DOI: 10.32614/CRAN.package.censobr.
}
